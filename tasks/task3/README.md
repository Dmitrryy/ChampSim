# Task 3: Q/A

## Объясните смысл и напишите формулы для следующих метрик производительности процессора IPC, CPI, Performance, Dynamic Power

### IPC (instructions per cycle)
среднее количество инструкций, исполняемых процессором за 1 такт. Это мера того, насколько эффективно CPU использует каждый такт для выполнения инструкций:
$$ \text{IPC} = \frac{\text{Instructions Executed}}{\text{Clock Cycles}} $$

### CPI (cycles per instruction) 
CPI представляет собой среднее количество тактов, которое требуется для выполнения каждой инструкции. Это противоположность IPC и дает представление об эффективности выполнения инструкций.
$$ \text{CPI} = \frac{\text{Clock Cycles}}{\text{Instructions Executed}} $$
$$ \text{CPI} = \frac{1}{\text{IPC}} $$

### Performance 
Производительность - насколько быстро процессор может выполнить заданную задачу или выполнить определенное количество инструкций. Одним из распространенных способов количественно оценить производительность является время выполнения программы или задачи.

$$ \text{Performance} = \frac{1}{\text{Execution Time}} $$

$$ \text{Execution Time} = \text{Instructions Executed} \times \text{CPI} \times \text{Clock Cycle Time} $$
$$\text{Clock Cycle Time} = \frac{1}{\text{Clock Frequency}}$$

### Dynamic Power
Динамическая мощность — это мощность, потребляемая процессором в результате переключения транзисторов во время работы. Это значительная составляющая общего энергопотребления процессоров.
$$ P_{\text{dynamic}} = C \times V^2 \times f $$
Где:
- $ P_{\text{dynamic}} $ — динамическая мощность.
- $C$ — переключаемая за цикл емкость.
- $V$ — напряжение.
- $f$ — тактовая частота.


## Что такое суперскалярный (superscalar) процессор?
Суперскалярный процессор — это тип микропроцессора, который может выполнять более одной инструкции в течение одного такта, отправляя несколько инструкций соответствующим исполнительным блокам внутри ЦП. Эта возможность обеспечивает параллельное выполнение инструкций и, таким образом, повышает общую производительность процессора. КАк пример: АЛУ, векторные или VLIW инструкции.


## Какие типы зависимостей по данным существуют? Приведите примеры аппаратных оптимизаций, которые позволяют сократить связанные задержки или разрешить каждый тип зависимостей.

### 1. Data Dependency (RAW)
Происходит, когда инструкции требуется значение, созданное предыдущей инструкцией.

```assembly
I1: R1 = R2 + R3   ; I1 produces a value in R1
I2: R4 = R1 + R5   ; I2 consumes the value produced by I1
```
Оптимизации:
- **Forwarding/Bypassing:** Этот метод позволяет передавать выходные данные одной инструкции непосредственно в следующую инструкцию без обратной записи в файл регистров.
- **Out-of-Order Execution:** Инструкции выполняются, как только становятся доступны их операнды, не обязательно в том порядке, в котором они появляются в программе.

### 2. Name Dependency
#### a. Anti-dependency (WAR)
Происходит, когда инструкции необходимо выполнить запись в регистр, из которого считывается предыдущая инструкция.

```assembly
I1: R4 = R2 + R3   ; I1 reads R2 and R3
I2: R2 = R1 + R5   ; I2 writes to R2
```
Оптимизации:
- **Register Renaming:** Аппаратное обеспечение динамически переименовывает регистры, чтобы избежать конфликтов, эффективно устраняя зависимость, позволяя различным инструкциям использовать разные физические регистры.

#### b. Output Dependency (WAW)
Происходит, когда две инструкции записывают в один и тот же регистр. Порядок записи должен быть сохранен для обеспечения корректности.

```assembly
I1: R1 = R2 + R3   ; I1 writes to R1
I2: R1 = R4 + R5   ; I2 also writes to R1
```
Оптимизации:
- **Register Renaming:** Опять же, переименование регистров может устранить эту зависимость, гарантируя, что каждая запись выполняется в уникальный физический регистр.


## С какой целью инструкцию Store разделяют на микро-операции STA (Store address calculation) и STD (Store data calculation)?

* уменьшить количество зависимостей между инструкциями загрузки (load) и сохранения (store). Такие зависимости возникают, когда операции чтения и записи используют пересекающиеся адреса. Обычно адрес для операции store определяется только после подготовки данных для записи. Предлагается вычислять адрес store заранее, до формирования данных, чтобы снизить количество зависимостей load/store.

## Объясните назначение и функции следующих аппаратных структур: ROB, Scheduler Queue (Issue Queue, Reservation Station), RAT, PRF, Load Buffer, Store Buffer

### Reorder Buffer (ROB)
Поддерживать порядок программы и обеспечивать правильное завершение инструкций при спекулятивном исполнении. Управляет и обрабатывает исключения и неверные прогнозы, позволяя процессору вернуться к заведомо исправному состоянию.

### Scheduler Queue (Issue Queue, Reservation Station)
Управляет планированием и отправкой инструкций соответствующим исполнительным блокам.

Функции:
* временно удерживает инструкции, ожидающие отправку на исполнительные устройства.
* отслеживает зависимости данных между инструкциями, чтобы гарантировать, что инструкции выполняются только тогда, когда их операнды готовы.
* Динамическое планирование: позволяет выдавать инструкции не по порядку в зависимости от доступности операндов и готовности исполнительного устройства, тем самым улучшая параллелизм на уровне инструкций (ILP).

### Register Alias Table (RAT)
Для переименования регистров и устранения ложных зависимостей данных (WAR и WAW).

Функции:
* Переименование регистров: сопоставляет логические регистры, используемые в программе, с физическими регистрами, чтобы избежать зависимости имен и обеспечить выполнение вне очереди.
* Разрешение зависимостей: помогает разрешать антизависимости (WAR) и выходные зависимости (WAW), предоставляя уникальные сопоставления для каждого использования регистра.

### Physical Register File (PRF)
Для хранения фактических значений данных переименованных регистров.

Функции:
* Хранение данных: хранит значения всех физических регистров, используемых процессором.
* Доступ для чтения/записи: обеспечивает доступ для чтения и записи к значениям данных для исполнительных устройств.
* Управление переименованными регистрами: работает совместно с RAT для поддержания состояния переименованных регистров и их сопоставлений.

### Load Buffer
Для управления инструкциями загрузки и их зависимостями.

Функции:
* Удержание инструкций загрузки: временно удерживает инструкции загрузки до тех пор, пока они не будут выполнены.
* Расчет адреса: вычисляет эффективный адрес для инструкций загрузки.
* Проверка зависимостей: гарантирует, что инструкции загрузки выполняются в правильном порядке относительно других операций с памятью, чтобы поддерживать согласованность памяти.

### Store Buffer
Для управления инструкциями store и обеспечения правильных операций с памятью.

Функции:
* Хранение инструкций store: временно удерживает инструкции по хранению до тех пор, пока не будут готовы их действующие адреса и данные.
* Расчет адреса: вычисляет эффективный адрес для инструкций store.
* Управление записью в память: гарантирует, что операции store выполняются в правильном порядке, и при необходимости обрабатывает пересылку данных на последующие загрузки (store-to-load forwarding).

## Пусть каждая 5ая инструкция в процессоре это Branch. Предсказатель переходов имеет точность 90%. Оцените, ROB какого максимального размера имеет смысл для такого процессора.
20% (1 in 5) всех инструкций являются бранчами.

Частота неправильных предсказаний равна $ 20\% \times 10\% = 2\% $.

Тогда в среднем неправильное предсказание происходит каждые $ \frac{1}{0.02} = 50 $ инструкций. Делать буфер сильно больше смысла нет. Можно взять на ~20% больше для покрытия весомого хвоста вероятностей.

## Что такое Memory Disambiguation?
Устранение неоднозначности памяти — это метод, используемый для обработки и оптимизации выполнения операций с памятью при наличии потенциальных зависимостей данных. Он направлен на устранение неопределенностей в отношении зависимостей между доступами к памяти для улучшения параллелизма на уровне инструкций (ILP).

Метод позволяют процессору динамически прогнозировать и проверять зависимости между операциями с памятью, обеспечивая внеочередное выполнение операций загрузки и сохранения без нарушения корректности программы.

## В чем заключается проблема со спекулятивным исполнением Store инструкций?
* Спекулятивное выполнение инструкций store может нарушить когерентность и согласованности памяти, особенно в многоядерных или многопроцессорных системах.
* Спекулятивные store должны быть скрыты от других инструкций до момента их коммита.
* Неправильно предполагаемые store необходимо откатить, не затрагивая состояние архитектуры.
* store-to-load forwarding становится более сложным в случае спекулятивных store.
* Реализация механизмов обработки спекулятивных store увеличивает нагрузку на производительность.

## Что такое Store forwarding и Load speculation в OOO процессоре?
### Store Forwarding
Store forwarding это механизм, позволяющий команде load получать данные непосредственно из предыдущей инструкции store, а не ждать, пока store запишет свои данные в память. Полезно, когда сохранение и последующая загрузка обращаются к одному и тому же адресу памяти.

### Load Speculation
Load speculation это метод, при котором процессор спекулятивно выполняет инструкции load до того, как будет уверен, что адреса предыдущих инструкций store были разрешены. Это позволяет процессору продолжать работу, а не останавливаться, но при этом возникает необходимость обеспечения правильности.

## Что такое Simultaneous Multithreading?
SMT — это метод для улучшения производительности одного физического процессора, позволяя ему одновременно выполнять несколько независимых потоков. Это достигается за счет дублирования определенных разделов процессора, таких как файлы состояния архитектуры и регистров, при совместном использовании других ресурсов, таких как исполнительные блоки и кэши.
